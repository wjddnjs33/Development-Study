---
layout: post
date: 2021-08-07 00:00:11
title: "Cross-site leak with Cache Probing"
categories: CTF
tags: [XS-Leak]
author:
  - Jeongwon Jo

---
# Summary

An XS-Leak is a vulnerability that can collect important data such as user information using the browser result for users based input value. If you want to study in deeping an xs-leak, You can study that refer to [here](https://xsleaks.dev/) :) 

---
# What is cache probing

![image](https://user-images.githubusercontent.com/49112423/128534023-67aa205b-41be-4d9c-8f06-215b2b3d8a5c.png)

It is said that the loading speed of the resource file is different from the first time the browser loads the resource file and from the second time. The reason is that the second time the resource file is fetched, the image cache is fetched from disk, not by requesting it from the web server.

![image](https://user-images.githubusercontent.com/49112423/128535171-7f89b779-f375-4854-a2ea-4267d2021c68.png)

The photo on the right is when the image is first loaded, and the photo on the left is when the image is loaded the second time. If you look at the time, you can see that there is a difference by the ratio of `0ms : 48ms`. So how can use this to link with XS-Leak?

---
# Exploit (Web) UIU CTF 2021 - yana [342 pts]

> The challenge is leak the flag and using the cache probing and xs-leak :)

![image](https://user-images.githubusercontent.com/49112423/128590914-4d24779e-058f-4bec-845b-f3882d3557ef.png)

If you went to the challenge, you can see a notepad function as above. I checked, the function as top is to save a content and function as bottom is to search for saved memo.

![image](https://user-images.githubusercontent.com/49112423/128591264-a708f372-8f69-4a76-9328-12e2933eacd7.png)

So, I saved a memo as `pocas` and `not_pocas`. I did a saerch for `pocas` on the left and searched for `asdf` on the right after saved the memo.

OMG, I did a search and came up with surprising result!! It was immediately returned with a different color image!! I can know an important information here.

- Information

1. If you search for a cunrently saved memo, a green image appears.
2. If you search for a unsaved memo, a red image appears.

```javascript
const noteForm = document.getElementById("note");
noteForm.onsubmit = (e) => {
    e.preventDefault();
    window.localStorage.setItem("note", new FormData(noteForm).get("note"));
};

const searchForm = document.getElementById("search");
const output = document.getElementById("output");
searchForm.onsubmit = (e) => {
    e.preventDefault();
    const query = new FormData(searchForm).get("search") ?? "";
    document.location.hash = query;
    search();
};

function search() {
    const note = window.localStorage.getItem("note") ?? "";
    console.log(`note: ${note}`);
    const query = document.location.hash.substring(1);
    console.log(`query: ${query}`);
    if (query) {
        if (note.includes(query)) {
            console.log('found');
            output.innerHTML =
            'found! <br/><img src="https://sigpwny.com/uiuctf/y.png"></img>';
        } else {
            console.log('not found');
            output.innerHTML =
            'nope.. <br/><img src="https://sigpwny.com/uiuctf/n.png"></img>';
        }
    }
}
search();
```
Now that I've done a functiona analysis, let's analyze the client-side code.

- Analysis ( search() )

1. Get the currently stored content value using `window.localStorage.getItem("note")`.
2. Get the query value using `document.location.hash.substring(1)`.
3. Use `note.includes(query)` to check whether the value of the query is included in the note. ( Important )
4. If the query value is included in the note, a green image appears, otherwise a red image appears.

```js
/*
NOTE: this is the script that the admin bot runs to visit your provided URL
it not required to solve the challenge, but is provided for reference & for you to help test/debug your exploit
*/

const { chromium } = require('playwright-chromium');
const fs = require('fs');
const net = require('net');

const FLAG = fs.readFileSync('/flag.txt', {encoding: 'utf-8'});
// matches regex: uiuctf{[a-z0-9_]}

(async function () {
  const browser = await chromium.launch({
    executablePath: "/playwright/chromium-878941/chrome-linux/chrome",
    logger: {
      isEnabled: () => true,
      log: (name, severity, message, _args) => console.log(`chrome log: [${name}/${severity}] ${message}`)
    }
  });

  function ask_for_url(socket) {
    socket.state = 'URL';
    socket.write('Please send me a URL to open.\n');
  }

  async function load_url(socket, data) {
    let url = data.toString().trim();
    console.log(`checking url: ${url}`);
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      socket.state = 'ERROR';
      socket.write('Invalid scheme (http/https only).\n');
      socket.destroy();
      return;
    }
    socket.state = 'LOADED';

    // "incognito" by default
    const context = await browser.newContext();
    const page = await context.newPage();
    await page.goto("https://chal.yana.wtf");
    await page.fill('#note > textarea', FLAG);
    await page.click('#note > button');
    await page.waitForTimeout(500);
    await page.goto('about:blank');
    await page.waitForTimeout(500);
    socket.write(`Loading page ${url}.\n`);
    await page.goto(url);
    setTimeout(() => {
      try {
        page.close();
        socket.write('timeout\n');
        socket.destroy();
      } catch (err) {
        console.log(`err: ${err}`);
      }
    }, 60000);
  }

  var server = net.createServer();
  server.listen(1338);
  console.log('listening on port 1338');

  server.on('connection', socket => {
    socket.on('data', data => {
      try {
        if (socket.state == 'URL') {
          load_url(socket, data);
        }
      } catch (err) {
        console.log(`err: ${err}`);
      }
    });

    try {
      ask_for_url(socket);
    } catch (err) {
      console.log(`err: ${err}`);
    }
  });
})();
```

---











